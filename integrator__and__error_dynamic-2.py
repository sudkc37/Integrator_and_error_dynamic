# -*- coding: utf-8 -*-
"""Integrator_ and _error_dynamic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18F6huXBaHq-aHfOTnlGN0wjDA-nkcHxK
"""

#Error Analysis of Numerical Differentiation on function

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

dt = 0.1
t = np.linspace(0, 10, 60)
y0 = -2.0
f = np.sin(t)**3 + (np.exp(t)**-6) * 2  #this mimics the price move for very short interval
first_order = 3 * np.sin(t)**2 * np.cos(t) - 12 * np.exp(t)**-7    #first order of price moves

plt.plot(t, f, 'r--')
plt.plot(t, first_order, 'k')
plt.grid(True)
plt.legend(['Function', 'Derivative'])
plt.xlabel('time')
plt.ylabel('function')
plt.title('First order Vs Original Moves')
plt.ylim([-2, 3])
plt.show()



#forward approximation
for_appx = ((np.sin(t+dt)**3 + (np.exp(t+dt)**-6) * 2)  - (np.sin(t)**3 + (np.exp(t)**-6) * 2 )) / dt
#backward_approximation
back_appx = ((np.sin(t)**3 + (np.exp(t)**-6) * 2) - (np.sin(t-dt)**3 + (np.exp(t-dt)**-6) * 2)) /dt
#central_approximation
central_appx = ((np.sin(t+dt)**3 + (np.exp(t+dt)**-6) * 2) - (np.sin(t-dt)**3 + (np.exp(t-dt)**-6) * 2)) / (2*dt)

plt.figure(figsize=(20,6))
plt.subplot(1,2,1)
plt.plot(t, first_order, 'k')
plt.plot(t,for_appx, 'b' )
plt.plot(t, back_appx, 'g')
plt.plot(t, central_appx, 'r')
plt.legend(['Exact Derivative', 'forward Euler','backward Euler','central Euler'])
plt.xlabel('time')
plt.ylabel('function')
plt.title('Error approximation of integrators')
plt.grid(True)
plt.ylim([-2, 3])
plt.show()

plt.figure(figsize=(20,6))
plt.subplot(1,2,1)
plt.plot(t, first_order, 'k')
plt.plot(t,for_appx, 'b' )
plt.plot(t, back_appx, 'g')
plt.plot(t, central_appx, 'r')
plt.legend(['Exact Derivative', 'forward Euler','backward Euler','central Euler'])
plt.xlim([7.5,8])
plt.ylim([-1,2])
plt.show()

"""#Discret Rieman integrals and Trapezoid Rules"""

a = 0  #starting integral point
b = 10 #ending integral point
dxf = 0.01
xf = np.linspace(a,b, int(b/dxf))
yf = np.sin(xf)
plt.plot(xf, yf,'k')


dxc = 0.5
xc = np.linspace(a,b, int(b/dxc))
edges = np.linspace(a,b, int(b/dxc)+1, endpoint=True)
yc = np.sin(xc)
plt.stairs(yc, edges, color='g')
plt.grid(True)
plt.show()

n = len(xc)

#left sided rectangle rule
left_sided_rectangle = 0
for i in range(n-1):
  left_sided_rectangle = left_sided_rectangle + yc[i]*dxc
print(left_sided_rectangle)

#right sided rectangle rule
right_sided_rectangle = 0
for i in range(n-1):
  right_sided_rectangle = right_sided_rectangle + yc[i+1]*dxc
print(right_sided_rectangle)

#trapezoid rule
trapezoid_rule = 0
for i in range(n-1):
  trapezoid_rule = trapezoid_rule +  (dxc/2) * (yc[i]+yc[i+1])
print(trapezoid_rule)

#Built in alternative trapezoid_rule is more accurate
trapezoid_rule = np.trapz(yf,xf)
trapezoid_rule



